import store from '../redux/store';
import { firestore } from '../firebase/firebase.utils';

let CURRENT_USER_ID;
let CART_ITEMS;

store.subscribe(() => {
  CURRENT_USER_ID = store.getState().user.currentUser?.id;
  CART_ITEMS = store.getState().cart.userCart.cartItems;
});

/**
 * handles the stripe payment process
 * @param {Object} cardInfo the stripe card element
 * @param {Object} stripeInstance the stripe promise instance
 */
export const handleStripePayment = async (cardInfo, stripeInstance) => {
  if (CURRENT_USER_ID) {
    try {
      const result = await stripeInstance.createToken(cardInfo);

      if (result.error) {
        return { type: 'error', errorMessage: result.error.message };
      } else {
        const response = await stripeTokenHandler(result.token);
        return response;
      }
    } catch (error) {
      return { type: 'error', errorMessage: error.message };
    }
  } else {
    return { type: 'error', errorMessage: 'You must be signed in to complete this process' };
  }
};

// FOR NOW, I HAVE NOT HANDLED THE BACKEND PART OF THE STRIPE PAYMENT PROCESS
// THIS WILL BE DONE WHEN I IMPLEMENT THE EXPRESS API FOR THE PROJECT

/**
 * handles the processing of the token generated by the stripe api
 * @param {String} token the token generated by the stripe api
 */
const stripeTokenHandler = async (token) => {
  try {
    // CALL THE BACKEND API TO PROCESS THE TOKEN
    // TODO
    await createAndUpdateOrders('Stripe');
    return { type: 'success' };
  } catch (error) {
    return error;
  }
};

/**
 * handles the successful PayPal payment response
 * @param {Object} data the data
 * @param {Object} actions the actions
 */
export const approvePayPalOrder = async (data, actions) => {
  if (CURRENT_USER_ID) {
    let response;

    try {
      await actions.order.capture();
      await createAndUpdateOrders('PayPal');
      response = { type: 'success' };
    } catch (error) {
      response = { type: 'error', errorMessage: error.message };
    }

    return response;
  } else {
    return { type: 'error', errorMessage: 'You must be signed in to complete this process' };
  }
};

/**
 * implements the creating the orders (if not exists) or updating the orders (if exists) functionality
 */
const createAndUpdateOrders = async (paymentType) => {
  try {
    const existingUserOrder = await firestore.collection('orders').where('userId', '==', CURRENT_USER_ID).get();

    if (!existingUserOrder.empty) {
      const batch = firestore.batch();
      const userOrder = existingUserOrder.docs.map((doc) => ({
        $key: doc.id,
        ...doc.data(),
      }))[0];

      CART_ITEMS.forEach((item) => {
        const existingOrderItemRef = firestore.collection('orders').doc(userOrder.$key).collection('orderItems').doc();
        batch.set(existingOrderItemRef, {
          ...item,
          createdAt: new Date(),
          paymentType,
        });
      });

      await batch.commit();
      return;
    } else {
      const batch = firestore.batch();
      const newUserOrder = await firestore.collection('orders').add({
        userId: CURRENT_USER_ID,
      });

      CART_ITEMS.forEach((item) => {
        const docRef = firestore.collection('orders').doc(newUserOrder.id).collection('orderItems').doc();
        batch.set(docRef, {
          ...item,
          createdAt: new Date(),
          paymentType,
        });
      });

      await batch.commit();
      return;
    }
  } catch (error) {
    return error;
  }
};
